J5  
“泛型”的意思是参数化类型。
类型安全，不需要显式类型转换
泛型只使用引用类型
有界类型
    extends superclass
    //supper subclass 没有上界 
通配符
    ？ 
    有界通配符
        extends superclass 
        extends subclass 
泛型继承关系
    实现类需要指定泛型接口相同的界限
    实现类指定界限后，implments 的接口不需要再指定
    实现类不指定泛型，implement 接口指定具体的类型
原始类型 
    泛型允许使用不提供类型参数的版本，Object 类型 替代 T  
    安全风险
    javac  warming
泛型类层次（继承关系）
    泛型层次中，类层次中的所有子类都必须向上传递超类锁需要的所有类型参数
    非泛型子类F
    运行时层次比较
        instanceof  ClassName<?> 
        不能指定具体的类型，应为泛型运行时不存在
    强制转换
        只有当两个泛型实例的类型相互兼容并且它们的类型参数也相同时，才能将其中的一个实例转换为另一个实例。
    重写泛型方法
        可以重写泛型方法
泛型类型推断
    <>
擦除
    编译java代码时，所有泛型信息被移除。使用界定类型替换类型参数，如果没有显示指定界定类型，就使用Object 

    桥接方法
        编译器偶尔需要为类添加桥接方法
            子类中重写方法的类型擦除不能产生与超类中方法相同的擦除
    模糊性错误
        擦除前不同的方法，擦除后变成相同的方法导致的冲突
        指定界限可以编译通过，最好使用不同的方法名

限制
    不能实例化类型参数
    静态成员不能使用类声明的类型参数（可以声明静态泛型方法）
    泛型数组
        不能实例化（可以使用通配符）
    泛型类不能扩展Throwable 
    