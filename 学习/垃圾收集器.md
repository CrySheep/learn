垃圾收集器

对象已死
    引用计数法：
        对象中添加一个计数器，对象被引用+1；引用失效-1；为0，对象失效

        有点：效率高。
        缺点：循环引用等问题
    可达性分析：
        通过一系列GC Roots 作为起点，根据引用关系向下搜索（引用链），对象没有引用链，对象失效

        GC Roots 对象：
            虚拟机栈中引用的对象
            方法去中类静态属性引用的对象
            方法区中常量引用的对象
            本地方法区中JNI引用的对象
            虚拟机内部的引用，Class对象、一场对象，系统类加载器等。
            同步锁持有的对象
            虚拟机内部情况 的JMXBean\JVMT中注册的回到、本地代码缓存等

引用： 
    reference类型
    引用扩充 1.2 
        强引用、软引用、弱引用、虚引用
            强引用：
                
                传统引用，存在，就不会被回收
                new
            软引用：
                有用非必须对象。发生内存溢出前，2次GC 时回收
                SoftReference
            弱引用：
                非必须对象，下次GC被回收
                WeakReference 
            虚引用：
                不影响gc，无法通过虚引用获取对象实例。只为了获得对象被回收的通知。

                PhatomReference 
finalize()
    两次标记
    不执行finalize（），没有覆盖方法，或已经被调用
    需要执行，对象放入 F-Queue ，低优先级 Finalizer线程，执行finzlize（）。标记F-Queue 中对象  

方法区回收：
    性价比低
    回收内容
        废弃的常量和不在使用的类型

        类型废弃条件：
            实例全部回收
            加载该类的类加载器已经被回收
            该类的java.lang.Class 对象没有被引用
垃圾收集算法：
    引用计数式垃圾收集算法和追踪式垃圾收集（直接收集和渐渐收集）

    追踪式垃圾收集算法
        分代收集理论：
            弱分代假说：大多对象朝生夕灭
            强分代假说：躲过多次垃圾回收的对象难以消亡

            跨代引用假说:跨代引用只占极少数

        Minor GC Major GC Full GC
        标记-复制算法 标记-清除算法 标记整理算法 

      

        分代： 
            新生代、老年代


        部分收集  Partial GC 

        新生代收集 Minor GC /Young GC 

        老年代收集 Major GC/Old GC ：只有 CMS；（有时候指整堆收集）
        
        混合收集 Mixed GC ：整个新生代和部分老年代。 只有G1 

        整堆收集  Full GC ：java 堆和方法区

        标记-清除算法
            最基础的算法，其他衍生
            缺点：
                执行效率不稳定
                空间碎片化
        标记-复制算法
            半区收集，划分两块。复制存活对象到另一块。整块清楚。

            优点：效率、内存连续
            缺点：浪费空间
                解决方式：
                    Appel 式回收：
                        新生代划分较大的Eden空间和两块较小的Survivor空间，每次分配内存使用Eden 和一块Survivor。发生GC时，复制存活对象到另一块，清除Eden 和已用的Survivor 。

                        逃生门

                        HotSpot Serial、ParNew 用来设计新生代
        标记-整理算法
            老年代
            标记-存活对象移到另一端-清理掉边界以外的内存。
            Stop the world 


            CMS ：
                平时采用标记-清除算法，空间碎片过多时，采用标记着呢管理算法
根节点枚举
    可达性分析 
    GC Root 
    引用链 

    GC Root 集合{全局性引用 （常量活类静态属性），执行上下文 （栈帧中的本地变量表）}
    时间停顿

    准确式垃圾回收 ，直接知道那些地方存放对象引用

    HotSpot 解决方案 OopMap 


    安全点：
        特定位置 记录了OopMap 信息
        程序执行必须到达安全点才能暂停

        不能太少，让收集器等待时间过长；不能太频繁，增加内存负荷


        实现方式：
            抢先式终端
            主动式中断

            抢先式终端：
                垃圾收集发生时，系统停止所有线程。如果用户线程中断的地方不是安全点，恢复线程，跑一会重新中断，直到安全点。（几乎没有虚拟机采用该方式）
            主动式终端：
                当垃圾收集需要终端线程时，仅仅设置一个标志位，各线程主动轮询该标志。发现中断标志位true ，主动在最近安全点中断。
    安全区域：
        安全点无法解决程序不执行时的问题。例如 sleep 和blocked 状态
        安全区域中的代码，引用关系不会发生变化。
        用户线程执行到安全区域时，标志自己进入安全区域。离开时检查虚拟机是否已经弯沉根节点枚举，已完成，继续执行，未完成，等到可以离开信号。
    记忆集
        为了解决跨代引用，新生代建立记忆集，用以避免把整个老年代加入GC root
        收集区指向非收集区 

经典垃圾收集器
    Serial  ParNew  ParallelScavenge 

    CMS     Serial Old  Parallel Old

    G1

    Serial - Parallel -CMS （concurrent mark sweep） - G1（Garbage first） - Shenandoah 和ZGC

    Serial  （Old）
        单线程 新生代复制算法，老年代，标记整理
        客户端模式默认新生代收集器。
        优点： 高效，内存少
    
    ParNew 
        Serial多线程版本 （所有参数、收集算法、stop the world 、对象分配规则、回收策略等）
        唯二能和CMS配合
        JDK9 不在推荐， 取消 -XX : +UseParNewGc 参数 
        -XX : ParallelGCThreads 设置线程 


    并行与并发：
        并行： 多条垃圾收集线程同时执行
        并发： 垃圾收集线程和用户线程同时执行

    Parallel Scavenge 收集器
        标记复制
        关注点：吞吐量  （运行用户代码时间/（运行用户代码时间+运行垃圾收集时间））
        -XX ： MaxGCPauseMills  最大来及收集停顿时间
        —XX ： GCTImeRation  吞吐量大小

        -XX ： +UseAdaptiveSizePolicy 自动分配新生代大小、Eden与Survivor 比例、晋升老年代对象大小等
    
    Serial Old 
        老年代版本
        作用：
            与Parallel Scavenge 搭配，作为CMS 后备预案。
    Parallel Old 
        Parallel Scavenge 老年代版本 
        标记整理 
        配合Parallel Scavenge 
    GMS 并行标记清除
        最短回收停顿时间为目标
        步骤
            初始标记
            并发标记
            重新标记
            并发清除

            初始标记和重新标记需要 stop the world 

            初始标记： GCROot 直接关联的对象
            并发标记从GCRoot 对象直接关联对象开始遍历整个对象图，耗时长

            重新标记：
                修正并发标记期间，变动的对象
            并发清除：
                清除标记溢出死对象
        优点
            并发收集、低停顿
        缺点
            处理器资源敏感（默认回收线程 （处理器数量+3）/4）（i-CMS j7 deprecated   j9 废弃）
            无法处理浮动垃圾，可能导致FullGC（on需要预留部分空间 -XX:CMSInitiatingOccu-pancyFracti）
            空间碎片过多（老年代存在大量空间而发生FullGC -XX:+UseCMS-CompactAtFullCollection FullGC 整理前压缩空间 J9废弃  -XX：CMSFullGCsBefore-Compaction  压缩空间前FullGC 次数J9废弃）
    Garbage First 
        局部收集设计思路，基于Region 的内存布局形式 
        主要面向服务端(J9 取代 Parallel Scavenge 和Parallel Old)
        新生代和老年代不在固定
        建立可预测的停顿时间模型，Region 作为单次回收的最小单元
        REgion 垃圾堆的价值大小，优先级列表（-XX:MaxGcPauseMillis 默认200毫秒）

        大致步骤
            初始标记 
            并发标记
            最终标记
            筛选回收

            初始标记 ： 
                只标记GCROot 直接关联对象，修改TAMS 指针的值，下一阶段用户线程并发运行时，能正确的在可用Region 中分配对象。与MinorGc同步完成

            并发标记 ： 
                从GCRoot对象开始可达性分析。对象图扫描完成后，还要重新处理SATB记录下的在并发时引用变动的对象
            最终标记：
                短暂暂停用户线程，标记鬓发阶段结束后任遗留下来的最后的少量SATB记录
            
            筛选回收：
                负责更新Region 的统计数据，堆各个Region 的回收价值和成本进行排序，根据用户期望的停顿时间来指定回收计划。回收集的存活对象复制到新的Region中，清理整个旧的Region 的空间（多线程并发执行）
        目标：延迟可控的情况下尽可能提高吞吐量
        从G1 开始，来及收集器设计导向不约而同的变为追求能够应付应用的内存分配律，而不追求一次把整个堆全部清理干净

        G1 Region  标记-复制 整体 标记-整理

        优势：
            没有碎片
            可以指定最大停顿时间
            分region的内存布局
            按收益动态确定回收集
        缺点： 
            垃圾收集产生的内存占用高
            程序运行时的额外执行负载高


垃圾收集器衡量指标
    内存占用、吞吐量和延迟
        
Shenandoah 
    步骤 
        初始标记 
        并发标记 
        最终标记 
        并发清理
        并发回收
        初始引用更新
        并发引用更新
        最终引用更新
        并发清理

        初始标记 
            GCRoots 直接关联对象
        并发标记 
            遍历对象图，标记出全部可达性的对象 
        最终标记 
            处理剩余SATB 扫描 ，统计高回收价值Region 
        并发清理
            清理真个区域内连一个存货对象都没有的Region  
        并发回收
            复制存货对象到新Region 。     
        初始引用更新 
            建立一个线程集合点，确保所有并发会输阶段中进行的收集器都已完成分配给它们的对象移动任务。
        并发引用更新 
            真正开始引用根性操作，与用户形成一起并发。按照内存物理地址顺序，线性地搜索出引用类型，把旧地址改为新的即可。
        最终引用更新 
            解决了堆中的引用更新后，还要修正存在GCRoots中的引用。
        并发清理：
            旧Region 已无存货对象，全部i清理回收

ZGC 收集器
    JDK11 
    停顿时间有限
    大中小 Region 
        小 2M 小于 256Kb
        中 32M  大于256K 小于 4MB
        大  不固定 2MB 的整数倍 大于 4M
    并发整理 
        读屏障、染色指针
            染色指针大幅减少了内存屏障的使用，
    步骤
        初始标记 
        并发标记
        最终标记
        并发预备重分配
        并发重分配
        并发重映射

        并发标记 
            遍历对象图，在指针上标记
        并发预备重分配
            根据特定的查询条件统计得出本次收集过程瑶清理那些region
        并发重分配 
            和谐阶段，重分配集中的存货对象复制到新的Region 上，维护转发表
        并发重映射  
            重新分配旧引用
            自愈
    收集器权衡
        应用程序的主要关注点
        基础设施如何 
        JDK 的发行商版本时什么，版本号是多少

虚拟机及垃圾收集器日志
    JDK 9  -Xlog   
        -Xlog[:[[selector][:[:output][:[decorators][:output-options]]]]
        selector   Tag 和日志级别
            Trace Debug Info Warning Error Off

垃圾收集
    对象优先在Eden 分配
    大对象直接进入老年代
    长期存活的对象将进入老年代
    动态年龄判定
    空间分配担保 
    























        
    








        


        
