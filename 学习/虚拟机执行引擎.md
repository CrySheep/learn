虚拟机字节码执行引擎
- # java 虚拟机执行引擎
  - **概述**
    - 执行引擎是java虚拟机核心的组成部分之一。
    - 物理机 直接建立在处理器、缓存、指令集和操作系统上面
    - 虚拟机执行引擎 由软件自行实现。
    - 分类
        解释执行和编译执行
  - **运行时栈帧结构**
    以方法作为最基本的执行单元；栈帧则是用于支持虚拟机进行方法调用和方法执行背后的数据结构
  - **栈帧存储内容**
    局部变量表、操作数栈、动态链接、方法返回、其他额外信息

    栈帧大小编译时写入放发表的Code属性。栈帧需要多少内存，仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式

    位于顶部的栈帧才是生效的，称为当前栈帧，关联方法称为当前方法

    - **局部变量表**
       变量值的存储空间，用于存放*方法参数*和方法内部定义的*局部变量*。

       最小单位：变量槽。每个槽应该能存放一个boolean byte char short int float reference returnAddress 类型（32位或更小）

       变量槽复用。被其他变量使用前可能导致变量不会被回收

       *局部变量*没有准备阶段，只定义*不赋值*不能使用
       *类变量*两次赋值：*准备阶段*赋予初始值，*初始化*阶段赋予程序定义值

    - **操作数栈**
       后入先出栈。最大深度编译时写入code属性的max_stacks数据项之中。32位栈容量1,64位2.

       基于栈的执行引擎，栈就是操作数栈

       操作栈共享区域： 大多数虚拟机实现里两个栈帧会出现一部分重叠。下面栈帧的部分操作数栈与上面栈帧的局部变量表重叠一起。节约空间、进行方法调用时直接共用一部分数据。
    - **动态链接**
       每个栈帧包含一个指向运行时常量池中该栈帧所属方法的引用。为了支持方法调用中的动态连接

       class文件常量池中村咋大量的符号引用。符号引用部分在类加载时转换位直接引用，称为静态解析。另一部分在每一次运行期间转换为直接引用，动态链接。

    - **方法返回**
       两种方式退出：遇到方法返回的字节码指令（正常调用完成）和遇到未捕获的异常（异常调用完成）
       正常退出，主调方法PC计数器作为返回地址。异常退出通过异常处理器表来确定

       退出时可能执行的操作： 恢复上层方法的局部变量表和操作数栈，返回值压入调用者栈帧的操作数栈，调整PC计数器，指向后面的一条指令
       
    - **其他额外信息**
       规范允许虚拟机实现增加一些规范里没有描述的信息到栈帧中

       与动态链接、方法返回信息归类位一类，称为栈帧信息

- **方法调用** 
    方法调用唯一的任务时确定被调用放啊发的版本，未涉及执行

    静态解析： 类加载阶段，转换位符号引用。成立前提是：方法在程序真正运行之前就有一个可确定的调用版本，且运行期间不可改变。这类方法的调用被称为解析。主要有静态方法和私有方法两大类

    **指令集**
        invokestatic  调用静态方法
        invokespecial 调用用实例构造器、私有方法和父类方法
        invokevirtual 调用虚方法
        invokeinterface 接口方法
        invokedynamic 运行时动态解析出调用点限定符所引用
        ’‘
        的方法

        invokestatic 和invokespecial都可以解析时确定。静态方法、私有方法、实例构造器、父类方法。以及final 方法（invokevirtual）。非虚方法
    **分派调用：**
        静态和动态分派
        单分派和多分派（宗量）
        静态单分派、静态多分派、动态单分派、动态多分派
        - 静态分派 MEthod Overload REsolution
            Human man = new Man() 
                Human 变量的*静态类型*或*外观类型*
                Man *实际类型*或*运行时类型*
            所有以来*静态类型*来决定*方法执行版本*的分派动作，都称为静态分派。最典型的应用表现就是*方法重载*。静态分派发生在*编译阶段*

            **静态类型** **方法执行版本** **方法重载** **编译阶段**

            重载版本并*不唯一*，只能确定*相对合适*的版本。字面量天生模糊性
            char>int>long>float>double>装箱>转型接口（多接口会导致歧义）>转型父类（优先级继承关系至下而上）>变长参数
          
        - 动态分派
            重写
            invokevirtual  指令
               1. 找到操作数栈第一个元素的实际类型。记作C
               2. 如果C中找到与常量中的描述符和简单名称都相符的方法，则进行权限校验，通过返回方法直接引用。不通过返回java.lang.IllegalAccessError
               3. 否则，按照继承关系从下往上一次对C的各个父类进行第二部搜索和验证
               4. 如果找不到合适方法，抛出java.lang.AbstractMethodError

            重写本质:
               invokevirtual 指令不是把常量池中方法的符号引用解析到直接引用上旧结束了，还会根据方法接收者的实际类型来选择方法。
            我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派
         - 单分派与多分派u

            方法的*接收者*与方法的*参数*统称位方法的*宗量*
            根据分派基于多少种宗量，可以将分派划分位*单分派*和*多分分派*。
            - 单分派
               根据一个宗量对目标方法进行选择
               java语言的动态分派属于但分派类型
            - 多分派
               根据多于一个宗量对目标济宁选择
               java中静态分派属于多分派
            java语言是一门静态多分派，动态单分派
      - 虚拟机动态分派的实现 
      - 动态类型 
        - java.lang.invoke 包
            Reflection 和 MethodHandle
            - Reflection 
               模拟代码层次的方法调用
               Method 

            - MethodHandle
               模拟字节码层次的方法调用
               Lookup


        - 



            





