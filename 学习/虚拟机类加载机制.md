虚拟机类加载机制
# 虚拟机类加载机制

- java 虚拟机把描述类的数据从Class文件加载到内存，并堆数据进行校验、转换解析和初始化

- 类的加载、连接和初始化都在程序运行期间完成

**类加载的时机**  
    1. 加载
    2. 链接
       1. 验证
       2. 准备
       3. 解析
    3. 初始化
    4. 使用
    5. 卸载
加载、验证、准备、初始化和卸载的顺序确定

**初始化**
1. 遇到new、getstatic、putstatic、invokestatic指令  
   1. 使用new关键字
   2. 读取活设置一个类型的静态字段（final修饰）
2. 使用java.lang.reflect 包的方法堆类型进行反射调用的时候
3. 当初始化类的时候，父类没有初始化
4. 虚拟机启动时，用户需要指定一个执行的朱磊
5. 动态语言支持时，java.lang.invoke.MethodHandle为 REF_getStatic\REF_putStatic\REF_invokeStatic\REF_newInvokeSpecial四种类型
6. 接口定义了默认方法，实现类发生初始化前

**类加载的过程**
1. 加载 
   1. 通过一个类的全限定名来获取定义此类的二进制字节流
   2. 将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构
   3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

    数组类加载：
        数组类不通过类加载器创建，由虚拟机直接在内存中动态构造出来。

        元素类型 ： 去掉所有维度

        组件类型 ：去掉一个维度 

        数组类创建规则：
         1. 如果数组的组件类型时引用类型，那旧递归采用加载过程去加载这个组件类型
         2. 组件类型不是引用类型，java 虚拟机将会把数组C 标记为引导类加载器关联
         3. 数组类克访问行与他的组件类型可访问行一致。如果组件类型不是引用类型，默认为public 
2. 验证
   确保class文件包含符合规范的要求
    文件格式验证
        主要目的： 字节流是否符合Class文件格式的规范
       1. 文件格式验证——开头，
       2. 版本号
       3. 是否有不被支持的常量类型
       4. 指向常量的各种索引值是否由指向不存在的常量活不符合类型的常量
       5. CONSTANT_uTF8_INFO 常量中是否由不符合UTF-8编码的数据
       6. 其他部分信息是否完整
    元数据验证
        主要目的： 对元数据信息进行语义校验。
        . 是否是有父类
        . 这个类的父类是否继承了不允许被继承的类
        . 如果这个类不是抽象类，是否实现了父类活接口之中要求实现的所有方法
        . 类中的字段、方法是否与弗雷产生矛盾（继承、重载等错误）
    元数据验证
        主要目的：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。对类的方法体进行校验分析

        StackMapTable属性，校验优化，移到javac中。 描述了方法所在的基本快开始时本地变量表和操作栈应有的状态。
    符号引用校验 
        发生在符号引用转化为直接引用的时候，在解析阶段发生

        符号引用校验 看作堆类自身意以外的各类信息进行匹配新校验（是否缺少或者禁止访问它以来的外部类、方法、字段等）
        . 字符串描述的全限定名是否找到对应的类
        . 类中是否存在符合方法的字段买哦书符及简单名称所描述的方法和字段
        . 符号引用中的类、字段、方法的可访问行是否可被当前类访问

        java.lang.IncompatibleClassChangeError子类 
3. 准备 
    是正式为类中定义的变量（静态变量）分配内存并设置变量初始值的阶段
    字段属性表 中 ConstantValue 属性，存储static final 变量值 
4. 解析 
   将常量池的符号引用替换为直接引用的过程
    符号引用： 以一组符号来描述引用的目标，可以时任何形式的字面量，只要无歧义。
    直接引用： 直接指向目标的指针、相对偏移量或一个能间接定位目标的句柄。

    类或接口的解析：
        D类中符号引用N 解析为C的戒指引用
        1. C不是数组类型，虚拟机把N的全限定名传递给D的类加载器去加载类C。
        2. C是数组类型，且元素类型为对象，按1加载元素据类型。
        3. 前两步没有异常，确认D是否有C的访问权限，否则抛出java.lang.IllegalAccessError .J9 引入模块化后，还要验证模块访问权限
    字段解析 
        字段所属类C 
        解析clas_index对应的Constant_claas_info符号进行解析。也就是字段所属类活接口的符号引用。
        1. C 本身包含简单名称和字段描述符都与目标相匹配的字段，返回这个字段的直接引用
        2. 否则，如果C中实现了接口，按照继承关系从下往上递归搜索接口和父接口。如果接口包含了简单名称和字段描述符都与目标相匹配的字段，返回字段的直接引用，结束查找。
        3. 否则，如果C不是java.lang.Object.按继承关系从下往上递归搜索父类，如果父类包含了简单名称和描述符都与目标相匹配的字段，返回之u姐引用，结束查找
        4. 否则，查找失败，抛出java.lang.NoSuchFieldError

        查找成功返回引用，将进行权限验证。（Java.lang.IllegalAccessError）
    方法解析
        解析方法表class_index 项中索引的方法所属的类或接口的符号引用
        1. Claas 文件格式中的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现Class_index 中索引的C是个接口的化，那旧直接抛出java.lang.IncompatibleClassChangeError一场
        2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标想匹配的方法，如果有则返回这个方法的直接引用，查找结束
        3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标想匹配的方法吗，如果有则返回这个方法的直接引用，查找结束
        4. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都匹配的方法，有则说明是抽象类，抛出异常java.lang.AbstractMethodError。
        5. 否则，查找失败，抛出java.lang.NoSuchMethodError
        最后，如果返回了直接引用，将进行过权限验证，抛出异常java.lang.IllegalAccessError 
    接口方法解析 
        首先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用。
        1. 如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么旧直接抛出java.lang.IncompatibleClassChangeError 
        2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法如果有则返回这个方法的直接引用
        3. 否则，在接口C的夫接口中递归查找，直到javalang.Objectd 类（接口查找也会包括Objecgt类）为止，看是否有简单名称和描述符都与目标方法想匹配的方法，有返回方法的直接引用
        4. 接口多继承，多个夫接口中存在相同的匹配，那将返回其中一个并结束。（不同javac实现不同）
        5. 否则，抛出java.lang.NoSuchMethodError 

        j9之前接口方法默认public，无权限访问问题。j9 增加了接口的静态私有方法，也有了模块化的访问约束，所以会抛出java.lang.IllegalAccessError
5. 初始化
    初始化阶段你是类加载过程的最后一个步骤，java虚拟机才真正开始执行类中编写的java程序代码。
    执行<clinit>()方法。该方法由javac编译器自动生成。编译器自动收集类中的所有类变量的复值动作和静态语句开static{}块中的语句产生（顺序为出现的顺序）（只能访问之前定义的静态属性，可以复制之后定义的属性）
    不需要显示调用父类的构造器。java虚拟机保证子类<clinit>()方法执行在夫方法之后。（父类静态语句先与子类复制）
    接口可以定义静态变量，所以接口也有<clinit>()方法.执行子接口clinit方法不需要执行父接口clinit放啊发
    多线程其他线程阻塞或等待，只有一个线程执行clinit 方法


类加载器
    通过一个类的全限定名来获取描述该类的二进制字节流的代码被称为类加载器

    比较两个类是否相等，必须是同一个类加载器（equals isAssignableFrom isInstance instanceof）

双亲委派模型
    java分类
        启动类加载器、其他所有的类加载器

    三层类加载器，双亲委派加载架构

    3个系统提供的类加载器
        启动类加载器
            负责加载<Java_home>\lib 目录，或者被 -Xbootclasspath 参数指定的路径中存放的，而且是java虚拟机能够识别的文件名。
        扩展类加载器
            这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以java代码的形式实现的。负责加载<java_home>\lib\ext目录中，或者被 java.ext.dirs系统变量锁指定的路径中所由的类库。（允许用户将具有通用性的类库放到ext目录，j9被模块化取代）（由java代码实现，可以直接使用扩展类夹杂其）
        应用程序类加载器
            由sun.misc.Launcher$AppClassLoader来实现。（ClassLoader 的 getSystem-ClassLoader 方法返回）负责加载用户类路径上的类库。可以直接在代码中使用这个加载器。

        组合关系
        双亲委派工作过程：
            如果一个类加载器收到了类加载的请求，首先不会自己区尝试加载这个类，而是把这个请求委派给父类加载器区完成，每一个层次的类加载器都是这样。父类加载器无法完成请求时，子加载器才会尝试自己区完成加载

        双亲委派的好处：
            java中的类随它的加载器一起具备了一种带有优先级的层次关系。

        对java程序的稳定运作极为重要

    破坏双亲委派
        3此大规模“被破坏”的情况 
            1. 1.2提出双亲委派，为了兼容老代码，ClassLoader中添加一个新的protected方法 findClass，并引导用户别写的类加载逻辑时区重新该方法，而不是loadClass
            2. 双亲委派很好地解决了各个类加载器写作时基础类型的一致性问题，如果基础类需要调用用户代码。例如：JNDI，对资源进行查找和同意管理，需要调用厂商提供的部署在应用程序Classpath下的jndi服务提供者结构（SPI）的代码。java 设计团队引入了线程上下文类加载器。通过Thread类的setContextClassLoader方法进行设置。默认从父线程继承一个。全局没有设置，默认应用程序类加载器（JNDI JDBC JCE JAXB JBI）（JDK 6 java.util.ServiceLoader类，以 META-INF/services中的配置信息，辅以责任链模式，）
            3. 由于用户对程序动态性的追求导致。（代码热替换、模块热部署）（JSR-294、JSR-277；JSR-291（OSGi R4.2））
                OSGi 热部署，关键时自定义的类加载机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换时，bundle连同类加载器一起替换掉。类加载器不在时双亲委派，二十网状结构
                OSGI 搜索方式
               1. 将以java.*开头的类，委派给父类加载器加载
               2. 否则，将委派列表名单内的类，委派给父类加载器加载
               3. 否则，将Import列表中的类，委派个Export这个类的Bundle的类加载器加载
               4. 否则，查找当前Bundle的ClassPath使用自己的类加载器加载
               5. 否则，查找类是否在自己的Fragment Bundle 中，如果在则委托给Fragment Bundle 的类加载器加载
               6. 否则，查找Dynamic import 泪飙中的Bundle，委派给对应的Bundle的咧加载器加载。
               7. 否则，类查找失败。
java模块化
    JDK9 java 模块化系统（JPMS）
    模块关键目标——可配置的封装隔离机制。

    java 模块定义包含的内容
        以来其他模块的列表
        导出的包列表，即其他模块可以使用的里欸博爱
        开放的包列表，即其他模块可反射访问模块的列表
        使用的服务列表
        提供服务的实现列表
    首先解决基于类路径来查找以来的可靠性问题。（发生类加载、链接时才会报错）模块化封装后，模块就可以声明对其他模块的显示依赖，这样java虚拟机旧能够在启动时验证应用程序依赖关系是否完备。
    然后，还解决了类路径上跨jar包public 类型的可访问行问题。


    模块的兼容性
        模块路径，某个类库是模块还是传统包，只取决放在哪个路径上。（不管是否包含module-info.class文件，是否JMOD后缀）

        访问规则
            1. jar文件在类路径： 所有类路径下的jar文件及其资源文件，都被视为自动打包在一个匿名模块里，匿名模块几乎没有任何隔离。可以看到类路径上的包，jdk系统的包，以及模块路径上所有模块中导出的包。
            2. 模块在在模块路径访问规则： 模块路径下的具名模块只能访问到它以来定义中列明以来的模块和包，匿名模块里所有的内容对具名模块来说是不可见的（看不见传统jar包）
            3. jar文件在模块路径。传统jar包（不包含模块定义文件）放到模块路径下，变为自动模块。自动模块默认依赖于整个模块中的所有模块。可以访问所有模块导出的包。自动模块也默认导出自己所有的包
        模块管理和兼容问题：人工选择正确版本的模块来保证依赖性
            java.base@12.0.1
            module_version_index
            javac --module-version 
            java.lang.module.ModuleDescriptor.Version 获取模块版本
        类加载器
            首先、扩展类加载器被平台类加载器取代。（rt.jar 和tools.js被拆为数十个JMOD文件）（无需保留javahome\lib\ext目录，java.ext.dirs系统变量）（取消javahome\jre目录 可以通过 jlink -p $JAVA_HOME/jmods --add-modules java.base --output jre 生成）
            其次 平台类加载器和应用程序类加载器不在派生自java.net.URLClassLoader（启动类加载器、平台类加载器、应用程序类加载器全部继承jdk.internal.loader.BuiltinClassLoader 实现了新的模块化架构）（启动类加载器现在是java虚拟机内部和java类库共同协作实现的类加载器。为了兼容获取启动类加载器的场景依然返回null）
            最后 委派关系发生了变化。平台应用程序类加载器收到类加载请求，在委派给父加载器器加载之前，先判断该类是否能够归属到摸一个系统模块，如果可以找到这个归属关系，优先委派给负责那个模块的加载器完成加载。

   





   

        



